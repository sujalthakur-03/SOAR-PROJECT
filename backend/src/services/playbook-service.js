/**
 * Playbook Service
 * Business logic for playbook CRUD operations with MongoDB
 *
 * IMPORTANT: Uses playbook_id (logical ID) for lookups, NOT MongoDB _id
 */

import mongoose from 'mongoose';
import { Playbook, PlaybookVersioned, Webhook } from '../models/index.js';
import logger from '../utils/logger.js';

/**
 * Helper to find playbook by playbook_id or MongoDB _id
 * Supports both legacy Playbook model and versioned PlaybookVersioned model
 */
async function findPlaybookByIdOrLogicalId(id) {
  // First try as playbook_id in legacy model
  let playbook = await Playbook.findOne({ playbook_id: id });

  // If not found and it looks like a MongoDB ObjectId, try that
  if (!playbook && mongoose.Types.ObjectId.isValid(id)) {
    playbook = await Playbook.findById(id);
  }

  // Check PlaybookVersioned (v2 versioned playbooks)
  if (!playbook) {
    const versioned = await PlaybookVersioned.findOne({ playbook_id: id, enabled: true });
    if (versioned) {
      return versioned;
    }
  }

  return playbook;
}

/**
 * Get all playbooks with optional filters
 */
export async function getPlaybooks(filters = {}) {
  try {
    const query = {};

    if (filters.status) {
      query.status = filters.status;
    }

    if (filters.tags && filters.tags.length > 0) {
      query.tags = { $in: filters.tags };
    }

    if (filters.severity) {
      query.severity = filters.severity;
    }

    const playbooks = await Playbook.find(query)
      .sort({ created_at: -1 })
      .lean();

    return playbooks.map(p => ({
      ...p,
      id: p._id.toString()
      // playbook_id is already in the document from the schema
    }));
  } catch (error) {
    logger.error('Failed to get playbooks:', error);
    throw error;
  }
}

/**
 * Get single playbook by playbook_id or MongoDB _id
 */
export async function getPlaybook(id) {
  try {
    const playbook = await findPlaybookByIdOrLogicalId(id);

    if (!playbook) {
      return null;
    }

    const result = playbook.toObject ? playbook.toObject() : playbook;
    return {
      ...result,
      id: result._id.toString()
    };
  } catch (error) {
    logger.error(`Failed to get playbook ${id}:`, error);
    throw error;
  }
}

/**
 * Create new playbook
 */
export async function createPlaybook(data, userId) {
  try {
    const playbook = new Playbook({
      // playbook_id is auto-generated by the schema
      name: data.name,
      description: data.description || '',
      tags: data.tags || [],
      severity: data.severity || 'medium',
      status: data.status || 'draft',
      trigger_type: data.trigger_type || 'webhook',
      steps: data.steps || [],
      matching_rules: data.matching_rules || {},
      expected_schema: data.expected_schema || {},
      created_by: userId || 'system',
      version: 1
    });

    await playbook.save();

    logger.info(`Playbook created: ${playbook.playbook_id} (${playbook.name})`);

    return {
      ...playbook.toObject(),
      id: playbook._id.toString()
    };
  } catch (error) {
    logger.error('Failed to create playbook:', error);
    throw error;
  }
}

/**
 * Update playbook
 */
export async function updatePlaybook(id, updates, userId) {
  try {
    const playbook = await findPlaybookByIdOrLogicalId(id);

    if (!playbook) {
      throw new Error('Playbook not found');
    }

    // Update fields
    if (updates.name) playbook.name = updates.name;
    if (updates.description !== undefined) playbook.description = updates.description;
    if (updates.tags) playbook.tags = updates.tags;
    if (updates.severity) playbook.severity = updates.severity;
    if (updates.status) playbook.status = updates.status;
    if (updates.steps) playbook.steps = updates.steps;
    if (updates.matching_rules !== undefined) playbook.matching_rules = updates.matching_rules;
    if (updates.expected_schema !== undefined) playbook.expected_schema = updates.expected_schema;

    playbook.updated_by = userId || 'system';
    playbook.version += 1;

    await playbook.save();

    logger.info(`Playbook updated: ${playbook.playbook_id} (${playbook.name})`);

    return {
      ...playbook.toObject(),
      id: playbook._id.toString()
    };
  } catch (error) {
    logger.error(`Failed to update playbook ${id}:`, error);
    throw error;
  }
}

/**
 * Toggle playbook status (enable/disable)
 */
export async function togglePlaybook(id, enabled) {
  try {
    const playbook = await findPlaybookByIdOrLogicalId(id);

    if (!playbook) {
      throw new Error('Playbook not found');
    }

    playbook.status = enabled ? 'active' : 'inactive';
    await playbook.save();

    logger.info(`Playbook ${enabled ? 'enabled' : 'disabled'}: ${playbook.playbook_id} (${playbook.name})`);

    return {
      ...playbook.toObject(),
      id: playbook._id.toString()
    };
  } catch (error) {
    logger.error(`Failed to toggle playbook ${id}:`, error);
    throw error;
  }
}

/**
 * Delete playbook
 */
export async function deletePlaybook(id) {
  try {
    const playbook = await findPlaybookByIdOrLogicalId(id);

    if (!playbook) {
      throw new Error('Playbook not found');
    }

    await Playbook.deleteOne({ _id: playbook._id });

    logger.info(`Playbook deleted: ${playbook.playbook_id} (${playbook.name})`);

    return { success: true };
  } catch (error) {
    logger.error(`Failed to delete playbook ${id}:`, error);
    throw error;
  }
}

/**
 * Get webhook information for a playbook
 * Supports both legacy (embedded webhook) and v2 (separate Webhook collection) models
 */
export async function getWebhookInfo(id, baseUrl) {
  try {
    const playbook = await findPlaybookByIdOrLogicalId(id);

    if (!playbook) {
      throw new Error('Playbook not found');
    }

    const playbookId = playbook.playbook_id;

    // Legacy model: webhook is embedded in playbook document
    if (playbook.webhook && playbook.webhook.secret) {
      return {
        playbook_id: playbookId,
        playbook_name: playbook.name,
        webhook_enabled: playbook.webhook.enabled,
        webhook_url: typeof playbook.getWebhookUrl === 'function'
          ? playbook.getWebhookUrl(baseUrl)
          : `${baseUrl}/api/webhooks/${playbookId}`,
        secret_last_rotated: playbook.webhook.last_rotated,
        created_at: playbook.webhook.created_at
      };
    }

    // V2 model: webhook is in separate Webhook collection
    const webhook = await Webhook.findByPlaybookId(playbookId);
    if (!webhook) {
      return {
        playbook_id: playbookId,
        playbook_name: playbook.name,
        webhook_enabled: false,
        webhook_url: null,
        secret_last_rotated: null,
        created_at: null,
        message: 'No webhook configured'
      };
    }

    return {
      playbook_id: playbookId,
      playbook_name: playbook.name,
      webhook_id: webhook.webhook_id,
      webhook_enabled: webhook.enabled,
      webhook_url: `${baseUrl}/api/webhooks/${webhook.webhook_id}`,
      secret_last_rotated: webhook.secret_rotated_at,
      created_at: webhook.created_at
    };
  } catch (error) {
    logger.error(`Failed to get webhook info for playbook ${id}:`, error);
    throw error;
  }
}

/**
 * Rotate webhook secret
 */
export async function rotateWebhookSecret(id) {
  try {
    const playbook = await findPlaybookByIdOrLogicalId(id);

    if (!playbook) {
      throw new Error('Playbook not found');
    }

    await playbook.rotateWebhookSecret();

    logger.info(`Webhook secret rotated for playbook: ${playbook.playbook_id} (${playbook.name})`);

    return {
      playbook_id: playbook.playbook_id,
      secret: playbook.webhook.secret,
      last_rotated: playbook.webhook.last_rotated
    };
  } catch (error) {
    logger.error(`Failed to rotate webhook secret for playbook ${id}:`, error);
    throw error;
  }
}

/**
 * Toggle webhook enabled status
 */
export async function toggleWebhook(id, enabled) {
  try {
    const playbook = await findPlaybookByIdOrLogicalId(id);

    if (!playbook) {
      throw new Error('Playbook not found');
    }

    await playbook.toggleWebhook(enabled);

    logger.info(`Webhook ${enabled ? 'enabled' : 'disabled'} for playbook: ${playbook.playbook_id} (${playbook.name})`);

    return {
      playbook_id: playbook.playbook_id,
      webhook_enabled: playbook.webhook.enabled
    };
  } catch (error) {
    logger.error(`Failed to toggle webhook for playbook ${id}:`, error);
    throw error;
  }
}

export default {
  getPlaybooks,
  getPlaybook,
  createPlaybook,
  updatePlaybook,
  togglePlaybook,
  deletePlaybook,
  getWebhookInfo,
  rotateWebhookSecret,
  toggleWebhook
};
